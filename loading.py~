import os
import numpy as np
import matplotlib.pyplot as plt
from numpy import arange as ar
from itertools import product
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel as C
from sklearn.preprocessing import minmax_scale as MMS

def list_dates(dates):
    ''' [[2013, 5, 6, 7], [2014, 5, 6, 7]] --> ['201305','201306',...]'''
    def f(x, y):
        if y > 9:
            return str(x) + str(y)
        else:
            return str(x) + '0' + str(y)
    return [f(x[0], x[i]) for x in dates for i in range(1, len(x))]

# [[2013,5,6,7],[2014,5,6,7]] ->'20130506072014050607'
def to_string(t): return ''.join(str(x[0])+'0'+'0'.join(str(i) for i in x[1:]) for x in t)


class DataLoader:
    def __init__(self, LAT, LON, LVL, version,
                 grad_height=1,
                 input_vars=None,
                 dates=[[2013, 5, 6, 7], [2014, 5, 6, 7]],
                 when='20132014050607',
                 dir_load=r'E:\physicsMsc\research\code\data',
                 scale='none',
                 add_time=True,
                 add_day=False,
                 finite_diff='center'):
        self.grad_height = grad_height
        self.scale_type = scale
        self.times = np.linspace(0.5, 23.5, 24)[1::3]
        self.dates = list_dates(dates)  # dates = [[2013,5,6,7],[2014,5,6,7]]
        self.ground_vars = ['TS', 'SWGDN', 'PBLH']
        self.level_vars = ['T', 'U', 'V', 'QV', 'P', 'PT', 'UV']
        self.grad_vars = ['U', 'V', 'PT', 'UV']
        self.all_level_vars = [var + str(i) for var in self.level_vars for i in range(15)]
        self.all_grad_vars = [var+'G'+str(i) for var in self.grad_vars for i in range(1, 14)]
        self.level_grad_vars = [var+'G'+str(grad_height) for var in self.grad_vars]
        self.vars = self.ground_vars + self.all_level_vars + self.all_grad_vars
        self.input_vars = ['TS', 'UV', 'QV', 'PS', 'PT1', 'SWGDN', 'TIME'] + self.in_grad_vars if input_vars is None else input_vars
        self.y = 'PBLH'
        height = [-0.006, 0.058, 0.189, 0.320, 0.454, 0.589, 0.726, 0.864,
                  1.004, 1.146, 1.290, 1.436, 1.584, 1.759, 1.988, 2.249]
        levels = [str(x) for x in range(1, len(height)-1)]
        self.dir_load = dir_load
        self.file_name = when+'LAT'+str(LAT)+'LON'+str(LON)+'LVL'+str(LVL)+str(version) + '.npy'
        fname = when + 'LAT' + str(LAT) + 'LON' + str(LON) + 'LVL0-14vers2.npy'
        self.data = np.load(os.path.join(self.dir_load, self.file_name), encoding='latin1')[()]
        data = np.load(os.path.join(self.dir_load, fname), encoding='latin1')[()]

        g, gas_const, P_0 = 9.81, 287.058, 1e3
        # GET PRESSURES, POTENTIAL TEMPERATURE, WIND SPEED MAGNITUDE for heights 0 - 14
        for date in self.dates:
            data[date + 'P0'] = data[date+'PS']
            data[date + 'UV0'] = data[date + 'U0'] ** 2 + data[date + 'V0'] ** 2
            data[date + 'PT0'] = data[date + 'T0'] * (P_0 / data[date + 'P0']) ** 0.286
            for l in range(1, len(height)):
                h = height[l - 1] - height[l]
                T = 0.5*(data[date + 'T' + str(l-1)]+data[date + 'T' + str(l)])
                data[date+'P'+str(l)] = data[date+'P'+str(l-1)]*np.exp(g*h/gas_const/T)
                data[date+'UV'+str(l)] = data[date+'U'+str(l)]**2 + data[date+'V'+str(l)]**2
                data[date+'PT'+str(l)] = data[date+'T'+str(l)]*(P_0/data[date+'P'+str(l)])**0.286

        # GET VERTICAL GRADIENTS BY FINITE DIFFERENCES
        for date in self.dates:
            for i in range(1, len(height)-1):
                for var in ['U', 'V', 'PT']:
                    if finite_diff == 'forward':
                        h = height[i+1]-height[i]
                        data[date+var+'G'+str(i)] = (data[date+var+str(i+1)]-data[date+var+str(i)])/h
                    elif finite_diff == 'back':
                        h = height[i] - height[i-1]
                        data[date+var+'G'+str(i)] = (data[date+var+str(i)]-data[date+var+str(i-1)])/h
                    else:
                        h = height[i+1] - height[i-1]
                        data[date+var+'G'+str(i)] = (data[date+var+str(i+1)]-data[date+var+str(i-1)])/h
                data[date+'UVG'+str(i)] = data[date+'UG'+str(i)]**2 + data[date+'VG'+str(i)]**2

        # ADD TIME or DAY
        for date in self.dates:  # date is like '201305'
            days = int(data[date + 'TS'].shape[0] / 8)
            if add_time:
                data[date + 'TIME'] = np.tile(self.times, days)
            if add_day:
                data[date + 'DAY'] = np.array([[i] * 8 for i in range(1, days + 1)]).reshape(-1)

        # TRIM DATA
        for date in self.dates:
            data[date + 'shape'] = [data[date + var].shape[0] for var in self.vars]
            print(data, data[date + 'shape'])
            if max(data[date + 'shape']) != min(data[date + 'shape']):
                for var in self.vars:
                    data[date + var] = data[date + var][:min(data[date + 'shape'])]

        # SCALING NEEDS WORK
        self.scale = {'TS': 300.0, 'QV': 0.01, 'U': 10.0, 'V': 10.0, 'UV': 10.0,
                      'PS': 900.0, 'SWGDN': 1000.0, 'PBLH': 1000.0, 'TIME': 10.0,
                      'T': 300.0, 'PT': 1.0}

        for var, lvl in product(self.level_vars, range(len(height))):
                self.scale[var+str(lvl)] /= self.scale[var]

        for var, lvl in product(self.grad_vars, range(1, len(height)-1)):
                self.scale[var+'G'+str(lvl)] /= self.scale[var]

        if scale == 'minmax':
            for date in self.dates:
                data[date + 'PBLH'] /= self.scale['PBLH']

        for date, var in product(self.dates, self.vars):
            if scale == 'max':
                data[date + var] /= max(data[date + var])
            elif scale == 'mean':
                data[date + var] /= np.mean(data[date + var])
            elif scale == 'minmax':
                min_pblh, max_pblh = min(self.data[date + 'PBLH']), max(self.data[date + 'PBLH'])
                print(min_pblh, max_pblh)
                X = self.data[date + var]
                self.data[date + var] = MMS(X, feature_range=(min_pblh, max_pblh))
            elif scale == 'custom':
                self.data[date + var] /= self.scale[var]

        for key in self.data.keys():
            print(key+' TS data : ', self.data[key].shape[0])

        self.data=data

    def load_data(self, train, test, interpolation=0, plot=False):
        # train and test of form train = [[2013,5,6,7],[2014,5,6,7]]

        train_dates = list_dates(train); test_dates = list_dates(test)
        dates = train_dates+test_dates

        if interpolation == 0:
            pass
        else:
            if plot:
                dir = r'E:\physicsMsc\research\code\plots\interpolation'
                folder = 'interpolation_' + str(interpolation) +\
                         'train_dates_'+to_string(train)+'test_dates_'+to_string(test)
                save_dir = os.path.join(dir, folder)
                if not os.path.exists(save_dir):
                    os.mkdir(save_dir)
            for date, var in product(dates, self.input_vars+['PBLH']):
                X, y = ar(len(self.data[date+var]))[:, None], self.data[date+var]
                gp = GaussianProcessRegressor(kernel=C(1.0, (1e-3, 1e3)) * RBF(10, (1e-2, 1e2)),
                                              n_restarts_optimizer=9, random_state=1337)
                gp.fit(X, y)
                print('fitting interpolation for '+date+var)
                x = np.linspace(0, X.shape[0], X.shape[0] * interpolation)[:, None]
                y_pred, sigma = gp.predict(x, return_std=True)
                self.data[date + var] = y_pred
                if plot:
                    plt.clf()
                    plt.plot(X, y, 'r-', lw=2, label=u'real ' + var)
                    plt.plot(x, y_pred, 'b-', lw=1, label=u'interpreted ' + var)
                    plt.plot(X, y, 'ro', label=u'real ' + var)
                    plt.plot(x, y_pred, 'bx', label=u'interpreted ' + var)
                    plt.fill(np.concatenate([x, x[::-1]]),
                             np.concatenate([y_pred - 1.9600 * sigma,
                                             (y_pred + 1.9600 * sigma)[::-1]]),
                             alpha=.5, fc='b', ec='None', label='95% confidence interval')
                    plt.xlabel(date)
                    plt.ylabel(var)
                    plt.legend(loc='best')
                    plt.savefig(os.path.join(save_dir, date+var+'.jpg'))
                    print('plotted : '+date+var)

        for var in self.vars:
            self.data['train'+var] = np.concatenate([self.data[date+var] for date in train_dates])
            self.data['test'+var]  = np.concatenate([self.data[date+var] for date in test_dates])

        x_train = np.concatenate([self.data['train'+var][:, None] for var in self.input_vars], axis=1)
        y_train = np.concatenate([self.data[date + self.y][:, None] for date in train_dates])

        x_test = np.concatenate([self.data['test'+var][:, None] for var in self.input_vars], axis=1)
        y_test = np.concatenate([self.data[date + self.y][:, None] for date in test_dates])

        return x_train, y_train, x_test, y_test

    def GPinterpolation(self, interpolation_vars=None, dates=None, plot=True):

        X,y = ar(len(self.data['201407PBLH']))[:,None], self.data['201407PBLH']
        print(X.shape,y.shape)
        kernel = C(1.0, (1e-3, 1e3)) * RBF(10, (1e-2, 1e2))
        gp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9,
                                      random_state=1337)

        gp.fit(X, y)

        x = np.linspace(0, X.shape[0], X.shape[0]*4)[:, None]
        print(x.shape)
        y_pred, sigma = gp.predict(x, return_std=True)

        fig = plt.figure()
        plt.plot(X, y, 'r-', lw=2, label=u'real pblh')
        plt.plot(x, y_pred, 'b-', lw=1, label=u'interpreted pblh')
        plt.plot(X, y, 'ro', label=u'real pblh')
        plt.plot(x, y_pred, 'bx', label=u'interpreted pblh')
        plt.fill(np.concatenate([x, x[::-1]]),
                 np.concatenate([y_pred - 1.9600 * sigma,
                                 (y_pred + 1.9600 * sigma)[::-1]]),
                 alpha=.5, fc='b', ec='None', label='95% confidence interval')
        plt.xlabel('time')
        plt.ylabel('PBLH')
        plt.legend(loc='upper left')
        plt.show()

    def plot_time_series(self, dates, num, dir=r'E:\physicsMsc\research\code\plots\timeseries'):
        # dates of [[2013,5,6,7],[2014,5,6,7]]
        if self.scale_type == 'custom':
            folder = self.scale_type+'scale_'+str(num)+''.join(var+'_'+str(self.scale[var]) for var in self.vars)
        else:
            folder = self.scale_type+'scale_'+str(num)
        save_dir = os.path.join(dir, folder)
        if not os.path.exists(save_dir):
            os.mkdir(save_dir)
        for date in list_dates(dates):
            for var in self.vars:
                plt.clf()
                plt.scatter(ar(len(self.data[date+var])), self.data[date+var], c='b', marker='x')
                plt.scatter(ar(len(self.data[date + 'PBLH'])), self.data[date + 'PBLH'], c='r', marker='x')
                plt.plot(ar(len(self.data[date+var])), self.data[date+var], 'b', lw=1)
                plt.plot(ar(len(self.data[date + 'PBLH'])), self.data[date + 'PBLH'], 'r', lw=1)
                plt.xlabel(date)
                plt.ylabel(var)
                plt.title('Time Series on '+date+' for '+var)
                plt.savefig(os.path.join(save_dir, 'TS'+date+var+'.jpg'))
                print('plotted : ' + date + var)

    def plot_time_series_grads(self, dates, num, dir=r'E:\physicsMsc\research\code\plots\timeseriesgrads'):
        # dates of [[2013,5,6,7],[2014,5,6,7]]

        folder = 'grads'+str(num)
        save_dir = os.path.join(dir, folder)
        if not os.path.exists(save_dir):
            os.mkdir(save_dir)
        for i in range(1, len(height) - 1):
            for date in list_dates(dates):
                vars=[var+str(i) for var in self.grad_vars]
                for var in vars:
                    plt.clf()
                    plt.scatter(ar(len(self.data[date+var])), self.data[date+var], c='b', marker='x')
                    plt.scatter(ar(len(self.data[date + 'PBLH'])), self.data[date + 'PBLH'], c='r', marker='x')
                    plt.plot(ar(len(self.data[date+var])), self.data[date+var], 'b', lw=1)
                    plt.plot(ar(len(self.data[date + 'PBLH'])), self.data[date + 'PBLH'], 'r', lw=1)
                    plt.xlabel(date)
                    plt.ylabel(var)
                    plt.title('Time Series on '+date+' for '+var)
                    plt.savefig(os.path.join(save_dir, 'TS'+date+var+'.jpg'))
                    print('plotted : ' + date + var)

    def plot_PBLH_vs_inputs(self, dates, num, dir=r'E:\physicsMsc\research\code\plots\pblhvsinputs'):
        # dates of [[2013,5,6,7],[2014,5,6,7]]
        save_dir = os.path.join(dir, "num"+str(num))
        if not os.path.exists(save_dir):
            os.mkdir(save_dir)
        for date in list_dates(dates):
            for var in self.vars:
                plt.clf()
                plt.scatter(self.data[date + var], self.data[date + 'PBLH'], marker='x')
                plt.xlabel(var)
                plt.ylabel(self.y)
                plt.title('PBLH versus'+var+'on'+date)
                plt.savefig(os.path.join(save_dir, 'PBLHvs'+var+date+'.jpg'))


if __name__ == '__main__':
    LAT = 44.75; LON = -80.3125; LVL = 1; version = 1;
    DL = DataLoader(LAT, LON, LVL, version)
    DL.plot_time_series(dates=[[2013,5,6,7],[2014,5,6,7]], num=3)
    #DL.load_data(train=[[2014,5,6]], test=[[2014,7]], interpolation=5)
